{"version":3,"file":"plugin.DOro0ux_.js","sources":["../../../../../src/plugin.ts"],"sourcesContent":["/*\r\n  Copyright (c) 2024 Charly Schmidt aka Picorims<picorims.contact@gmail.com>,\r\n\r\n  This Source Code Form is subject to the terms of the Mozilla Public\r\n  License, v. 2.0. If a copy of the MPL was not distributed with this\r\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n*/\r\n\r\n// EXPORTS AND IMPORTS ARE NOT ALLOWED IN THIS FILE, EXCEPT FOR TYPE IMPORTS.\r\n// DOING SO WILL **BREAK** THE PLUGIN,\r\n// AS THEY ARE CURRENTLY NOT SUPPORTED BY PENPOT!.\r\n// By convention, all code copied elements (instead of being imported)\r\n// uses the suffix \"_IC\".\r\n\r\nimport type { PenpotEvent } from '$lib/types/plugin_events';\r\nimport type { GenericRule, Pattern_v1, Rule, RuleKind } from '$lib/types/pattern';\r\nimport type { Board, Shape } from '@penpot/plugin-types';\r\n\r\nconst VERBOSE = false;\r\n\r\nenum PluginEvents_IC {\r\n\tNO_SELECTION = 'no-selection',\r\n\tONE_SELECTION = 'one-selection',\r\n\tMULTIPLE_SELECTION = 'multiple-selection',\r\n\tPATTERN_SELECTED = 'pattern-selected',\r\n\tPONG = 'pong',\r\n\tERROR = 'error',\r\n\tSEND_PATTERN = 'send-pattern',\r\n\tACKNOWLEDGE_UPDATE_PATTERN = 'acknowledge-update-pattern',\r\n\tSEND_PROGRESSION = 'send-progression'\r\n}\r\n\r\nenum UIEvents_IC {\r\n\tPING = 'ping',\r\n\tCREATE_PATTERN = 'create-pattern',\r\n\tREQUEST_CURRENT_PATTERN = 'request-current-pattern',\r\n\tUPDATE_PATTERN = 'update-pattern'\r\n}\r\n\r\ntype EventT = PenpotEvent<PluginEvents_IC | UIEvents_IC>;\r\n\r\nenum PluginDataKey {\r\n\tIS_PATTERN = 'isPattern',\r\n\tSOURCE_ID = 'sourceId',\r\n\tPATTERN = 'pattern',\r\n\tIS_SOURCE = 'isSource',\r\n\tROW_INDEX = 'rowIndex',\r\n\tCOLUMN_INDEX = 'columnIndex'\r\n}\r\n\r\nlet selectionCache: string[] = [];\r\nlet lockModifications = false;\r\n\r\npenpot.ui.open('Tiling Utility', '', {\r\n\twidth: 300,\r\n\theight: 300\r\n});\r\n\r\nfunction getDefaultPattern(): Pattern_v1 {\r\n\treturn {\r\n\t\tversion: 1,\r\n\t\tmode: 'grid',\r\n\t\trows: 5,\r\n\t\tcolumns: 5,\r\n\t\tradius: 50,\r\n\t\trotateAccordingToDirection: true,\r\n\t\trules: []\r\n\t};\r\n}\r\n\r\n/**\r\n * This class is responsible for applying rules to a position.\r\n * Each call to process will apply the rules to the given position\r\n * and return the new position. The memory is used to store the\r\n * state of the rules. As such, the order of processing is important.\r\n *\r\n * By convention, it should be iterated over rows first, then columns.\r\n */\r\nclass RuleHandler {\r\n\tconstructor(\r\n\t\tprivate memory: Map<string, string>,\r\n\t\tprivate transformer: RuleTransformer<RuleKind>,\r\n\t\tprivate rule: Rule,\r\n\t\tprivate patternMode: Pattern_v1['mode']\r\n\t) {}\r\n\r\n\tstatic fromRule(rule: Rule, patternMode: Pattern_v1['mode']): RuleHandler {\r\n\t\tconst transformer = ruleTransformer[rule.type];\r\n\t\tif (!transformer) {\r\n\t\t\tthrow new Error(`Unknown rule type: ${rule.type}`);\r\n\t\t}\r\n\t\tconst memory = ruleMemoryInitializer[rule.type]();\r\n\t\treturn new RuleHandler(memory, transformer, rule, patternMode);\r\n\t}\r\n\r\n\tprocess(shapeInfo: AbstractShapeInfo) {\r\n\t\tconst result = this.transformer(shapeInfo, this.memory, this.rule, this.patternMode);\r\n\t\tthis.memory = result.memory;\r\n\t\t// A transformer should **NEVER** leave the object in an invalid state.\r\n\t\tfixShapeInfo(result.shapeInfo);\r\n\t\treturn result.shapeInfo;\r\n\t}\r\n}\r\n\r\ntype RuleTransformer<T extends RuleKind> = (\r\n\tshapeInfo: AbstractShapeInfo,\r\n\tmemory: Map<string, string>,\r\n\trule: GenericRule<T>,\r\n\tpatternMode: Pattern_v1['mode']\r\n) => { shapeInfo: AbstractShapeInfo; memory: Map<string, string> };\r\n\r\n/**\r\n * Applies a rule to an abstract shape object.\r\n */\r\nconst ruleTransformer: { [K in RuleKind]: RuleTransformer<K> } = {\r\n\trandomize: (shapeInfo, memory, rule) => {\r\n\t\tconst min = Math.min(rule.from, rule.to);\r\n\t\tconst max = Math.max(rule.from, rule.to);\r\n\t\tconst property = rule.property;\r\n\t\tconst random = Math.random();\r\n\t\tconst value = min + random * (max - min);\r\n\t\tshapeInfo[property] = shapeInfo[property] + value;\r\n\r\n\t\treturn { shapeInfo: shapeInfo, memory };\r\n\t},\r\n\toffset: (shapeInfo, memory, rule, patternMode) => {\r\n\t\tif (patternMode === 'revolution') {\r\n\t\t\tconsole.warn('Offset rule is not supported in revolution mode');\r\n\t\t\treturn { shapeInfo, memory };\r\n\t\t}\r\n\r\n\t\tconst property = rule.property;\r\n\t\tconst offset = rule.offset;\r\n\t\tconst accumulate = rule.accumulate;\r\n\t\tconst row = shapeInfo.row;\r\n\t\tconst col = shapeInfo.column;\r\n\r\n\t\tlet appliedOffset;\r\n\t\tlet amount;\r\n\t\tif (property === 'x') {\r\n\t\t\tamount = col;\r\n\t\t} else if (property === 'y') {\r\n\t\t\tamount = row;\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Unknown offset property: ${property}`);\r\n\t\t}\r\n\t\tappliedOffset = amount * offset;\r\n\r\n\t\tif (accumulate) {\r\n\t\t\tfor (let i = 0; i < amount; i++) {\r\n\t\t\t\tappliedOffset += i * offset;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (property === 'x') {\r\n\t\t\tshapeInfo.x += appliedOffset;\r\n\t\t} else if (property === 'y') {\r\n\t\t\tshapeInfo.y += appliedOffset;\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Unknown offset property: ${property}`);\r\n\t\t}\r\n\r\n\t\treturn { shapeInfo, memory };\r\n\t}\r\n};\r\n\r\n/**\r\n * Prevents the shape from having invalid values.\r\n * @param shapeInfo the shape to fix\r\n */\r\nfunction fixShapeInfo(shapeInfo: AbstractShapeInfo) {\r\n\tshapeInfo.rotation = shapeInfo.rotation % 360;\r\n\tshapeInfo.width = Math.max(0, shapeInfo.width);\r\n\tshapeInfo.height = Math.max(0, shapeInfo.height);\r\n}\r\n\r\n/**\r\n * Initializes the memory for a rule. It can be empty.\r\n */\r\nconst ruleMemoryInitializer: Record<RuleKind, () => Map<string, string>> = {\r\n\trandomize: () => new Map<string, string>(),\r\n\toffset: () => new Map<string, string>()\r\n};\r\n\r\n/**\r\n * Handle messages from the UI\r\n */\r\npenpot.ui.onMessage<EventT>((message) => {\r\n\tconsole.log('received UI message', message);\r\n\tif (message.type === UIEvents_IC.PING) {\r\n\t\tpenpot.ui.sendMessage(PluginEvents_IC.PONG);\r\n\t} else if (message.type === UIEvents_IC.CREATE_PATTERN) {\r\n\t\tcreatePattern();\r\n\t} else if (message.type === UIEvents_IC.REQUEST_CURRENT_PATTERN) {\r\n\t\tif (selectionCache.length === 0) {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No selection' });\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst board = penpot.currentPage?.getShapeById(selectionCache[0]) as Board;\r\n\t\tif (board.getPluginData(PluginDataKey.IS_PATTERN) !== 'true') {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No pattern selected' });\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.SEND_PATTERN, content: getBoardPattern(board) });\r\n\t} else if (message.type === UIEvents_IC.UPDATE_PATTERN) {\r\n\t\tif (selectionCache.length === 0) {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No selection' });\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst board = penpot.currentPage?.getShapeById(selectionCache[0]) as Board;\r\n\t\tif (board.getPluginData(PluginDataKey.IS_PATTERN) !== 'true') {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No pattern selected' });\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst pattern = message.content as Pattern_v1;\r\n\t\tboard.setPluginData(PluginDataKey.PATTERN, JSON.stringify(pattern));\r\n\t\tdrawPattern(board);\r\n\t} else {\r\n\t\tconsole.error('Unknown message from UI:', message);\r\n\t}\r\n});\r\n\r\n/**\r\n * Listen to selection change\r\n */\r\npenpot.on('selectionchange', (selection) => {\r\n\tselectionCache = [...selection];\r\n\tif (selection.length === 0) {\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.NO_SELECTION });\r\n\t} else if (selection.length === 1) {\r\n\t\tconst shape = penpot.currentPage?.getShapeById(selection[0]);\r\n\r\n\t\tif (!shape) {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.NO_SELECTION });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst isPattern = shape.getPluginData(PluginDataKey.IS_PATTERN) === 'true';\r\n\t\tif (isPattern) {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.PATTERN_SELECTED });\r\n\t\t\tpenpot.ui.sendMessage({\r\n\t\t\t\ttype: PluginEvents_IC.SEND_PATTERN,\r\n\t\t\t\tcontent: getBoardPattern(shape as Board)\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ONE_SELECTION });\r\n\t\t}\r\n\t} else {\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.MULTIPLE_SELECTION });\r\n\t}\r\n});\r\n\r\n/**\r\n * Initializes a new board as a pattern, with a hidden copy of the selected shape\r\n * serving as the source of the pattern.\r\n * @returns\r\n */\r\nfunction createPattern() {\r\n\tconsole.info('Creating pattern');\r\n\tconst board = penpot.createBoard();\r\n\tboard.setPluginData(PluginDataKey.IS_PATTERN, 'true');\r\n\r\n\tconst selectedShape = penpot.currentPage?.getShapeById(selectionCache[0]);\r\n\tif (!selectedShape) {\r\n\t\tconsole.error('No shape selected');\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No shape selected' });\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst clone = selectedShape?.clone();\r\n\tclone.x = 0;\r\n\tclone.y = 0;\r\n\tclone.hidden = true;\r\n\tclone.blocked = true;\r\n\tclone.name += ' (source)';\r\n\tclone.setPluginData(PluginDataKey.IS_SOURCE, 'true');\r\n\r\n\tboard.appendChild(clone);\r\n\tboard.setPluginData(PluginDataKey.SOURCE_ID, clone.id);\r\n\tboard.name = 'Pattern';\r\n\tboard.fills = [];\r\n\r\n\t//TODO figure out why this does not work (creates positions issues once the clones are appended)\r\n\t// board.x = selectedShape.x + selectedShape.width + 200;\r\n\t// board.y = selectedShape.y;\r\n\r\n\tboard.setPluginData(PluginDataKey.PATTERN, JSON.stringify(getDefaultPattern()));\r\n\tdrawPattern(board);\r\n\tpenpot.ui.sendMessage({ type: PluginEvents_IC.SEND_PATTERN, content: getBoardPattern(board) });\r\n}\r\n\r\n/**\r\n *\r\n * @param board The board being the container of the pattern\r\n * @returns the parsed JSON pattern data\r\n */\r\nfunction getBoardPattern(board: Board): Pattern_v1 {\r\n\tif (board.getPluginData(PluginDataKey.IS_PATTERN) !== 'true') {\r\n\t\tconsole.error('Board is not a pattern');\r\n\t\tpenpot.ui.sendMessage({\r\n\t\t\ttype: PluginEvents_IC.ERROR,\r\n\t\t\tcontent: 'Board is not a pattern, returning default pattern'\r\n\t\t});\r\n\t\treturn getDefaultPattern();\r\n\t}\r\n\treturn JSON.parse(board.getPluginData(PluginDataKey.PATTERN)) as Pattern_v1;\r\n}\r\n\r\ninterface AbstractShapeInfo {\r\n\trow: number;\r\n\tcolumn: number;\r\n\tx: number;\r\n\ty: number;\r\n\trotation: number;\r\n\twidth: number;\r\n\theight: number;\r\n}\r\n\r\n/**\r\n * Clears existing shapes (except the source) in excess if any,\r\n * then create or modify all shapes and position them according\r\n * to the pattern configuration.\r\n * @param board The board being the container of the pattern\r\n * @returns\r\n */\r\nfunction drawPattern(board: Board) {\r\n\tif (lockModifications) {\r\n\t\tconsole.warn('Modifications are locked');\r\n\t\treturn;\r\n\t}\r\n\tlockModifications = true;\r\n\r\n\tconsole.info('Drawing pattern');\r\n\tif (board.getPluginData(PluginDataKey.IS_PATTERN) !== 'true') {\r\n\t\tconsole.error('Board is not a pattern');\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'Board is not a pattern' });\r\n\t\tlockModifications = false;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// clear existing shapes\r\n\r\n\t// Positioning seems to be based on the frame (aligned with the axes)\r\n\t// encapsulating the rotated element, based on the rotation of the previous draw.\r\n\t// This is hard to compensate, so clone caching is not done for now.\r\n\t// No significant performance gain was noticed with caching at the time\r\n\t// of the implementation causing issues.\r\n\r\n\tboard.children.forEach((shape) => {\r\n\t\tif (shape.getPluginData(PluginDataKey.IS_SOURCE) !== 'true') {\r\n\t\t\tshape.remove();\r\n\t\t}\r\n\t});\r\n\r\n\tconst pattern = getBoardPattern(board);\r\n\tconsole.debug('Pattern:', pattern);\r\n\tconst validity = checkPatternValidity(pattern);\r\n\tif (!validity.valid) {\r\n\t\tconsole.error('Invalid pattern:', validity.context);\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: validity.context });\r\n\t\tlockModifications = false;\r\n\t\treturn;\r\n\t}\r\n\r\n\t/**\r\n\t * rows, then columns, then positions\r\n\t */\r\n\tconst positions = new Map<number, Map<number, AbstractShapeInfo>>();\r\n\r\n\tconst sourceId = board.getPluginData(PluginDataKey.SOURCE_ID);\r\n\tconst source = board.children.find((shape) => shape.id === sourceId);\r\n\tif (!source) {\r\n\t\tconsole.error('No source shape found');\r\n\t\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ERROR, content: 'No source shape found' });\r\n\t\tlockModifications = false;\r\n\t\treturn;\r\n\t}\r\n\r\n\tboard.horizontalSizing = 'fix';\r\n\tboard.verticalSizing = 'fix';\r\n\r\n\t// compute base positions\r\n\tif (pattern.mode === 'revolution') {\r\n\t\tconst centerOffset = pattern.radius + source.height * pattern.rows;\r\n\t\tboard.resize(2 * centerOffset, 2 * centerOffset);\r\n\r\n\t\t// a row is a circle\r\n\t\tfor (let i = 0; i < pattern.rows; i++) {\r\n\t\t\tconst r = pattern.radius + i * source.height;\r\n\t\t\tconst columnPositions = new Map<number, AbstractShapeInfo>();\r\n\r\n\t\t\t// a column is a point on the circle\r\n\t\t\tfor (let j = 0; j < pattern.columns; j++) {\r\n\t\t\t\tconst x = r * Math.cos(j * ((2 * Math.PI) / pattern.columns)) + centerOffset;\r\n\t\t\t\tconst y = r * Math.sin(j * ((2 * Math.PI) / pattern.columns)) + centerOffset;\r\n\t\t\t\tconst rot = pattern.rotateAccordingToDirection\r\n\t\t\t\t\t? j * (360 / pattern.columns) + 90 // +90 because the revolution starts at 3 o'clock\r\n\t\t\t\t\t: 0;\r\n\t\t\t\tcolumnPositions.set(j, {\r\n\t\t\t\t\trow: i,\r\n\t\t\t\t\tcolumn: j,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty,\r\n\t\t\t\t\trotation: rot,\r\n\t\t\t\t\twidth: source.width,\r\n\t\t\t\t\theight: source.height\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tpositions.set(i, columnPositions);\r\n\t\t}\r\n\t} else if (pattern.mode === 'grid') {\r\n\t\tboard.resize(source.width * pattern.columns, source.height * pattern.rows);\r\n\t\t// y axis\r\n\t\tfor (let i = 0; i < pattern.rows; i++) {\r\n\t\t\tconst columnPositions = new Map<number, AbstractShapeInfo>();\r\n\r\n\t\t\t// x axis\r\n\t\t\tfor (let j = 0; j < pattern.columns; j++) {\r\n\t\t\t\tconst x = j * source.width;\r\n\t\t\t\tconst y = i * source.height;\r\n\t\t\t\tcolumnPositions.set(j, {\r\n\t\t\t\t\trow: i,\r\n\t\t\t\t\tcolumn: j,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty,\r\n\t\t\t\t\trotation: 0,\r\n\t\t\t\t\twidth: source.width,\r\n\t\t\t\t\theight: source.height\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tpositions.set(i, columnPositions);\r\n\t\t}\r\n\t}\r\n\r\n\t// apply rules\r\n\tconst ruleHandlers: RuleHandler[] = [];\r\n\tfor (const rule of pattern.rules) {\r\n\t\tif (rule.enabled) {\r\n\t\t\truleHandlers.push(RuleHandler.fromRule(rule, pattern.mode));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (let i = 0; i < pattern.rows; i++) {\r\n\t\tfor (let j = 0; j < pattern.columns; j++) {\r\n\t\t\tconst position = positions.get(i)?.get(j);\r\n\t\t\tif (!position) {\r\n\t\t\t\tconsole.error('No position found for', i, j);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (VERBOSE) console.debug('processing at', position);\r\n\r\n\t\t\tlet newPosition = position;\r\n\t\t\tfor (const handler of ruleHandlers) {\r\n\t\t\t\tnewPosition = handler.process(newPosition);\r\n\t\t\t}\r\n\t\t\tpositions.get(i)?.set(j, newPosition);\r\n\t\t}\r\n\t}\r\n\r\n\t// create shapes\r\n\tfor (let i = 0; i < pattern.rows; i++) {\r\n\t\tfor (let j = 0; j < pattern.columns; j++) {\r\n\t\t\tpenpot.ui.sendMessage({\r\n\t\t\t\ttype: PluginEvents_IC.SEND_PROGRESSION,\r\n\t\t\t\tcontent: { ratio: i / pattern.rows + (1 / pattern.rows / pattern.columns) * j }\r\n\t\t\t});\r\n\t\t\tconst position = positions.get(i)?.get(j);\r\n\t\t\tif (!position) {\r\n\t\t\t\tconsole.error('No position found for', i, j);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (VERBOSE) console.debug('updating at', position);\r\n\r\n\t\t\tconst clone: Shape | undefined = source.clone();\r\n\t\t\tclone.setPluginData(PluginDataKey.IS_SOURCE, 'false');\r\n\t\t\tclone.name = clone.name.replace(' (source)', ` (${i}, ${j})`);\r\n\t\t\tclone.setPluginData(PluginDataKey.ROW_INDEX, i.toString());\r\n\t\t\tclone.setPluginData(PluginDataKey.COLUMN_INDEX, j.toString());\r\n\t\t\t// Note: the clone is already a child of the board\r\n\t\t\tclone.hidden = false;\r\n\r\n\t\t\tif (!clone) {\r\n\t\t\t\tconsole.error('No clone found (this is not supposed to happen)');\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// apply data\r\n\t\t\tclone.blocked = false;\r\n\t\t\tclone.resize(position.width, position.height);\r\n\t\t\tif (pattern.mode === 'revolution') {\r\n\t\t\t\tclone.x = position.x - position.width / 2 + board.x;\r\n\t\t\t\tclone.y = position.y - position.height / 2 + board.y;\r\n\t\t\t} else if (pattern.mode === 'grid') {\r\n\t\t\t\tclone.x = position.x + board.x;\r\n\t\t\t\tclone.y = position.y + board.y;\r\n\t\t\t}\r\n\t\t\tclone.rotation = source.rotation;\r\n\t\t\tclone.rotate(position.rotation, {\r\n\t\t\t\tx: clone.x + clone.width / 2,\r\n\t\t\t\ty: clone.y + clone.height / 2\r\n\t\t\t});\r\n\t\t\tclone.blocked = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpenpot.ui.sendMessage({ type: PluginEvents_IC.ACKNOWLEDGE_UPDATE_PATTERN });\r\n\tlockModifications = false;\r\n}\r\n\r\n/**\r\n * Says if the pattern is valid or not. Stops at the first invalidity found.\r\n * @param pattern The pattern to check\r\n * @returns\r\n */\r\nfunction checkPatternValidity(pattern: Pattern_v1): { valid: boolean; context: string } {\r\n\tif (pattern.mode === 'revolution') {\r\n\t\tif (pattern.radius <= 0) {\r\n\t\t\treturn { valid: false, context: 'Radius must be greater than 0' };\r\n\t\t}\r\n\t}\r\n\tif (pattern.rows <= 0) {\r\n\t\treturn { valid: false, context: 'Rows must be greater than 0' };\r\n\t}\r\n\tif (pattern.columns <= 0) {\r\n\t\treturn { valid: false, context: 'Columns must be greater than 0' };\r\n\t}\r\n\treturn { valid: true, context: '' };\r\n}\r\n"],"names":["selectionCache","lockModifications","getDefaultPattern","RuleHandler","memory","transformer","rule","patternMode","ruleTransformer","ruleMemoryInitializer","shapeInfo","result","fixShapeInfo","min","max","property","random","value","offset","accumulate","row","col","appliedOffset","amount","message","_a","_b","createPattern","board","getBoardPattern","pattern","drawPattern","selection","shape","selectedShape","clone","_c","validity","checkPatternValidity","positions","sourceId","source","centerOffset","r","columnPositions","j","y","rot","i","x","ruleHandlers","position","newPosition","handler"],"mappings":"AAkDA,IAAIA,EAA2B,CAAC,EAC5BC,EAAoB,GAExB,OAAO,GAAG,KAAK,iBAAkB,GAAI,CACpC,MAAO,IACP,OAAQ,GACT,CAAC,EAED,SAASC,GAAgC,CACjC,MAAA,CACN,QAAS,EACT,KAAM,OACN,KAAM,EACN,QAAS,EACT,OAAQ,GACR,2BAA4B,GAC5B,MAAO,CAAA,CACR,CACD,CAUA,MAAMC,CAAY,CACjB,YACSC,EACAC,EACAC,EACAC,EACP,CAJO,KAAA,OAAAH,EACA,KAAA,YAAAC,EACA,KAAA,KAAAC,EACA,KAAA,YAAAC,CAAA,CAGT,OAAO,SAASD,EAAYC,EAA8C,CACnE,MAAAF,EAAcG,EAAgBF,EAAK,IAAI,EAC7C,GAAI,CAACD,EACJ,MAAM,IAAI,MAAM,sBAAsBC,EAAK,IAAI,EAAE,EAElD,MAAMF,EAASK,EAAsBH,EAAK,IAAI,EAAE,EAChD,OAAO,IAAIH,EAAYC,EAAQC,EAAaC,EAAMC,CAAW,CAAA,CAG9D,QAAQG,EAA8B,CAC/B,MAAAC,EAAS,KAAK,YAAYD,EAAW,KAAK,OAAQ,KAAK,KAAM,KAAK,WAAW,EACnF,YAAK,OAASC,EAAO,OAErBC,EAAaD,EAAO,SAAS,EACtBA,EAAO,SAAA,CAEhB,CAYA,MAAMH,EAA2D,CAChE,UAAW,CAACE,EAAWN,EAAQE,IAAS,CACvC,MAAMO,EAAM,KAAK,IAAIP,EAAK,KAAMA,EAAK,EAAE,EACjCQ,EAAM,KAAK,IAAIR,EAAK,KAAMA,EAAK,EAAE,EACjCS,EAAWT,EAAK,SAChBU,EAAS,KAAK,OAAO,EACrBC,EAAQJ,EAAMG,GAAUF,EAAMD,GACpC,OAAAH,EAAUK,CAAQ,EAAIL,EAAUK,CAAQ,EAAIE,EAErC,CAAE,UAAAP,EAAsB,OAAAN,CAAO,CACvC,EACA,OAAQ,CAACM,EAAWN,EAAQE,EAAMC,IAAgB,CACjD,GAAIA,IAAgB,aACnB,eAAQ,KAAK,iDAAiD,EACvD,CAAE,UAAAG,EAAW,OAAAN,CAAO,EAG5B,MAAMW,EAAWT,EAAK,SAChBY,EAASZ,EAAK,OACda,EAAab,EAAK,WAClBc,EAAMV,EAAU,IAChBW,EAAMX,EAAU,OAElB,IAAAY,EACAC,EACJ,GAAIR,IAAa,IACPQ,EAAAF,UACCN,IAAa,IACdQ,EAAAH,MAET,OAAM,IAAI,MAAM,4BAA4BL,CAAQ,EAAE,EAIvD,GAFAO,EAAgBC,EAASL,EAErBC,EACH,QAAS,EAAI,EAAG,EAAII,EAAQ,IAC3BD,GAAiB,EAAIJ,EAIvB,GAAIH,IAAa,IAChBL,EAAU,GAAKY,UACLP,IAAa,IACvBL,EAAU,GAAKY,MAEf,OAAM,IAAI,MAAM,4BAA4BP,CAAQ,EAAE,EAGhD,MAAA,CAAE,UAAAL,EAAW,OAAAN,CAAO,CAAA,CAE7B,EAMA,SAASQ,EAAaF,EAA8B,CACzCA,EAAA,SAAWA,EAAU,SAAW,IAC1CA,EAAU,MAAQ,KAAK,IAAI,EAAGA,EAAU,KAAK,EAC7CA,EAAU,OAAS,KAAK,IAAI,EAAGA,EAAU,MAAM,CAChD,CAKA,MAAMD,EAAqE,CAC1E,UAAW,IAAM,IAAI,IACrB,OAAQ,IAAM,IAAI,GACnB,EAKA,OAAO,GAAG,UAAmBe,GAAY,CAzIzC,IAAAC,EAAAC,EA2IK,GADI,QAAA,IAAI,sBAAuBF,CAAO,EACtCA,EAAQ,OAAS,OACb,OAAA,GAAG,YAAY,MAAoB,UAChCA,EAAQ,OAAS,iBACbG,EAAA,UACJH,EAAQ,OAAS,0BAAqC,CAC5D,GAAAxB,EAAe,SAAW,EAAG,CAChC,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,eAAgB,EAC9E,MAAA,CAED,MAAM4B,GAAQH,EAAA,OAAO,cAAP,YAAAA,EAAoB,aAAazB,EAAe,CAAC,GAC/D,GAAI4B,EAAM,cAAc,WAAwB,IAAM,OAAQ,CAC7D,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,sBAAuB,EACrF,MAAA,CAEM,OAAA,GAAG,YAAY,CAAE,KAAM,eAA8B,QAASC,EAAgBD,CAAK,EAAG,CAAA,SACnFJ,EAAQ,OAAS,iBAA4B,CACnD,GAAAxB,EAAe,SAAW,EAAG,CAChC,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,eAAgB,EAC9E,MAAA,CAED,MAAM4B,GAAQF,EAAA,OAAO,cAAP,YAAAA,EAAoB,aAAa1B,EAAe,CAAC,GAC/D,GAAI4B,EAAM,cAAc,WAAwB,IAAM,OAAQ,CAC7D,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,sBAAuB,EACrF,MAAA,CAED,MAAME,EAAUN,EAAQ,QACxBI,EAAM,cAAc,UAAuB,KAAK,UAAUE,CAAO,CAAC,EAClEC,EAAYH,CAAK,CAAA,MAET,QAAA,MAAM,2BAA4BJ,CAAO,CAEnD,CAAC,EAKD,OAAO,GAAG,kBAAoBQ,GAAc,CA/K5C,IAAAP,EAiLK,GADazB,EAAA,CAAC,GAAGgC,CAAS,EAC1BA,EAAU,SAAW,EACxB,OAAO,GAAG,YAAY,CAAE,KAAM,eAA8B,UAClDA,EAAU,SAAW,EAAG,CAClC,MAAMC,GAAQR,EAAA,OAAO,cAAP,YAAAA,EAAoB,aAAaO,EAAU,CAAC,GAE1D,GAAI,CAACC,EAAO,CACX,OAAO,GAAG,YAAY,CAAE,KAAM,eAA8B,EAC5D,MAAA,CAGiBA,EAAM,cAAc,WAA8B,IAAA,QAEnE,OAAO,GAAG,YAAY,CAAE,KAAM,mBAAkC,EAChE,OAAO,GAAG,YAAY,CACrB,KAAM,eACN,QAASJ,EAAgBI,CAAc,CAAA,CACvC,GAED,OAAO,GAAG,YAAY,CAAE,KAAM,gBAA+B,CAC9D,MAEA,OAAO,GAAG,YAAY,CAAE,KAAM,qBAAoC,CAEpE,CAAC,EAOD,SAASN,GAAgB,CA/MzB,IAAAF,EAgNC,QAAQ,KAAK,kBAAkB,EACzB,MAAAG,EAAQ,OAAO,YAAY,EAC3BA,EAAA,cAAc,YAA0B,MAAM,EAEpD,MAAMM,GAAgBT,EAAA,OAAO,cAAP,YAAAA,EAAoB,aAAazB,EAAe,CAAC,GACvE,GAAI,CAACkC,EAAe,CACnB,QAAQ,MAAM,mBAAmB,EACjC,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,oBAAqB,EACnF,MAAA,CAGK,MAAAC,EAAQD,GAAA,YAAAA,EAAe,QAC7BC,EAAM,EAAI,EACVA,EAAM,EAAI,EACVA,EAAM,OAAS,GACfA,EAAM,QAAU,GAChBA,EAAM,MAAQ,YACRA,EAAA,cAAc,WAAyB,MAAM,EAEnDP,EAAM,YAAYO,CAAK,EACjBP,EAAA,cAAc,WAAyBO,EAAM,EAAE,EACrDP,EAAM,KAAO,UACbA,EAAM,MAAQ,CAAC,EAMfA,EAAM,cAAc,UAAuB,KAAK,UAAU1B,EAAA,CAAmB,CAAC,EAC9E6B,EAAYH,CAAK,EACV,OAAA,GAAG,YAAY,CAAE,KAAM,eAA8B,QAASC,EAAgBD,CAAK,EAAG,CAC9F,CAOA,SAASC,EAAgBD,EAA0B,CAClD,OAAIA,EAAM,cAAc,WAAwB,IAAM,QACrD,QAAQ,MAAM,wBAAwB,EACtC,OAAO,GAAG,YAAY,CACrB,KAAM,QACN,QAAS,mDAAA,CACT,EACM1B,EAAkB,GAEnB,KAAK,MAAM0B,EAAM,cAAc,UAAsB,CAC7D,CAmBA,SAASG,EAAYH,EAAc,CAnRnC,IAAAH,EAAAC,EAAAU,EAoRC,GAAInC,EAAmB,CACtB,QAAQ,KAAK,0BAA0B,EACvC,MAAA,CAKD,GAHoBA,EAAA,GAEpB,QAAQ,KAAK,iBAAiB,EAC1B2B,EAAM,cAAc,WAAwB,IAAM,OAAQ,CAC7D,QAAQ,MAAM,wBAAwB,EACtC,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,yBAA0B,EACpE3B,EAAA,GACpB,MAAA,CAWK2B,EAAA,SAAS,QAASK,GAAU,CAC7BA,EAAM,cAAc,UAAuB,IAAM,QACpDA,EAAM,OAAO,CACd,CACA,EAEK,MAAAH,EAAUD,EAAgBD,CAAK,EAC7B,QAAA,MAAM,WAAYE,CAAO,EAC3B,MAAAO,EAAWC,EAAqBR,CAAO,EACzC,GAAA,CAACO,EAAS,MAAO,CACZ,QAAA,MAAM,mBAAoBA,EAAS,OAAO,EAC3C,OAAA,GAAG,YAAY,CAAE,KAAM,QAAuB,QAASA,EAAS,QAAS,EAC5DpC,EAAA,GACpB,MAAA,CAMK,MAAAsC,MAAgB,IAEhBC,EAAWZ,EAAM,cAAc,UAAuB,EACtDa,EAASb,EAAM,SAAS,KAAMK,GAAUA,EAAM,KAAOO,CAAQ,EACnE,GAAI,CAACC,EAAQ,CACZ,QAAQ,MAAM,uBAAuB,EACrC,OAAO,GAAG,YAAY,CAAE,KAAM,QAAuB,QAAS,wBAAyB,EACnExC,EAAA,GACpB,MAAA,CAOG,GAJJ2B,EAAM,iBAAmB,MACzBA,EAAM,eAAiB,MAGnBE,EAAQ,OAAS,aAAc,CAClC,MAAMY,EAAeZ,EAAQ,OAASW,EAAO,OAASX,EAAQ,KAC9DF,EAAM,OAAO,EAAIc,EAAc,EAAIA,CAAY,EAG/C,QAAS,EAAI,EAAG,EAAIZ,EAAQ,KAAM,IAAK,CACtC,MAAMa,EAAIb,EAAQ,OAAS,EAAIW,EAAO,OAChCG,MAAsB,IAG5B,QAASC,EAAI,EAAGA,EAAIf,EAAQ,QAASe,IAAK,CACnC,MAAA,EAAIF,EAAI,KAAK,IAAIE,GAAM,EAAI,KAAK,GAAMf,EAAQ,QAAQ,EAAIY,EAC1DI,EAAIH,EAAI,KAAK,IAAIE,GAAM,EAAI,KAAK,GAAMf,EAAQ,QAAQ,EAAIY,EAC1DK,EAAMjB,EAAQ,2BACjBe,GAAK,IAAMf,EAAQ,SAAW,GAC9B,EACHc,EAAgB,IAAIC,EAAG,CACtB,IAAK,EACL,OAAQA,EACR,EACA,EAAAC,EACA,SAAUC,EACV,MAAON,EAAO,MACd,OAAQA,EAAO,MAAA,CACf,CAAA,CAEQF,EAAA,IAAI,EAAGK,CAAe,CAAA,CACjC,SACUd,EAAQ,OAAS,OAAQ,CAC7BF,EAAA,OAAOa,EAAO,MAAQX,EAAQ,QAASW,EAAO,OAASX,EAAQ,IAAI,EAEzE,QAASkB,EAAI,EAAGA,EAAIlB,EAAQ,KAAMkB,IAAK,CAChC,MAAAJ,MAAsB,IAG5B,QAASC,EAAI,EAAGA,EAAIf,EAAQ,QAASe,IAAK,CACnC,MAAAI,EAAIJ,EAAIJ,EAAO,MACfK,EAAIE,EAAIP,EAAO,OACrBG,EAAgB,IAAIC,EAAG,CACtB,IAAKG,EACL,OAAQH,EACR,EAAAI,EACA,EAAAH,EACA,SAAU,EACV,MAAOL,EAAO,MACd,OAAQA,EAAO,MAAA,CACf,CAAA,CAEQF,EAAA,IAAIS,EAAGJ,CAAe,CAAA,CACjC,CAID,MAAMM,EAA8B,CAAC,EAC1B,UAAA5C,KAAQwB,EAAQ,MACtBxB,EAAK,SACR4C,EAAa,KAAK/C,EAAY,SAASG,EAAMwB,EAAQ,IAAI,CAAC,EAI5D,QAASkB,EAAI,EAAGA,EAAIlB,EAAQ,KAAMkB,IACjC,QAASH,EAAI,EAAGA,EAAIf,EAAQ,QAASe,IAAK,CACzC,MAAMM,GAAW1B,EAAAc,EAAU,IAAIS,CAAC,IAAf,YAAAvB,EAAkB,IAAIoB,GACvC,GAAI,CAACM,EAAU,CACN,QAAA,MAAM,wBAAyBH,EAAGH,CAAC,EAC3C,QAAA,CAID,IAAIO,EAAcD,EAClB,UAAWE,KAAWH,EACPE,EAAAC,EAAQ,QAAQD,CAAW,GAE1C1B,EAAAa,EAAU,IAAIS,CAAC,IAAf,MAAAtB,EAAkB,IAAImB,EAAGO,EAAW,CAKtC,QAASJ,EAAI,EAAGA,EAAIlB,EAAQ,KAAMkB,IACjC,QAASH,EAAI,EAAGA,EAAIf,EAAQ,QAASe,IAAK,CACzC,OAAO,GAAG,YAAY,CACrB,KAAM,mBACN,QAAS,CAAE,MAAOG,EAAIlB,EAAQ,KAAQ,EAAIA,EAAQ,KAAOA,EAAQ,QAAWe,CAAE,CAAA,CAC9E,EACD,MAAMM,GAAWf,EAAAG,EAAU,IAAIS,CAAC,IAAf,YAAAZ,EAAkB,IAAIS,GACvC,GAAI,CAACM,EAAU,CACN,QAAA,MAAM,wBAAyBH,EAAGH,CAAC,EAC3C,QAAA,CAIK,MAAAV,EAA2BM,EAAO,MAAM,EAQ9C,GAPMN,EAAA,cAAc,WAAyB,OAAO,EAC9CA,EAAA,KAAOA,EAAM,KAAK,QAAQ,YAAa,KAAKa,CAAC,KAAKH,CAAC,GAAG,EAC5DV,EAAM,cAAc,WAAyBa,EAAE,SAAA,CAAU,EACzDb,EAAM,cAAc,cAA4BU,EAAE,SAAA,CAAU,EAE5DV,EAAM,OAAS,GAEX,CAACA,EAAO,CACX,QAAQ,MAAM,iDAAiD,EAC/D,QAAA,CAIDA,EAAM,QAAU,GAChBA,EAAM,OAAOgB,EAAS,MAAOA,EAAS,MAAM,EACxCrB,EAAQ,OAAS,cACpBK,EAAM,EAAIgB,EAAS,EAAIA,EAAS,MAAQ,EAAIvB,EAAM,EAClDO,EAAM,EAAIgB,EAAS,EAAIA,EAAS,OAAS,EAAIvB,EAAM,GACzCE,EAAQ,OAAS,SACrBK,EAAA,EAAIgB,EAAS,EAAIvB,EAAM,EACvBO,EAAA,EAAIgB,EAAS,EAAIvB,EAAM,GAE9BO,EAAM,SAAWM,EAAO,SAClBN,EAAA,OAAOgB,EAAS,SAAU,CAC/B,EAAGhB,EAAM,EAAIA,EAAM,MAAQ,EAC3B,EAAGA,EAAM,EAAIA,EAAM,OAAS,CAAA,CAC5B,EACDA,EAAM,QAAU,EAAA,CAIlB,OAAO,GAAG,YAAY,CAAE,KAAM,6BAA4C,EACtDlC,EAAA,EACrB,CAOA,SAASqC,EAAqBR,EAA0D,CACnF,OAAAA,EAAQ,OAAS,cAChBA,EAAQ,QAAU,EACd,CAAE,MAAO,GAAO,QAAS,+BAAgC,EAG9DA,EAAQ,MAAQ,EACZ,CAAE,MAAO,GAAO,QAAS,6BAA8B,EAE3DA,EAAQ,SAAW,EACf,CAAE,MAAO,GAAO,QAAS,gCAAiC,EAE3D,CAAE,MAAO,GAAM,QAAS,EAAG,CACnC"}