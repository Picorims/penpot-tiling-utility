{"version":3,"file":"1.CrOjg6w7.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../../../../../../node_modules/svelte/src/internal/flags/legacy.js","../../../../../../node_modules/@sveltejs/kit/src/runtime/app/stores.js","../../../../../../node_modules/@sveltejs/kit/src/runtime/components/svelte-5/error.svelte"],"sourcesContent":["/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { component_context, deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","import { enable_legacy_mode_flag } from './index.js';\n\nenable_legacy_mode_flag();\n","import { getContext } from 'svelte';\nimport { BROWSER } from 'esm-env';\nimport { stores as browser_stores } from '../client/client.js';\n\n/**\n * A function that returns all of the contextual stores. On the server, this must be called during component initialization.\n * Only use this if you need to defer store subscription until after the component has mounted, for some reason.\n */\nexport const getStores = () => {\n\tconst stores = BROWSER ? browser_stores : getContext('__svelte__');\n\n\treturn {\n\t\t/** @type {typeof page} */\n\t\tpage: {\n\t\t\tsubscribe: stores.page.subscribe\n\t\t},\n\t\t/** @type {typeof navigating} */\n\t\tnavigating: {\n\t\t\tsubscribe: stores.navigating.subscribe\n\t\t},\n\t\t/** @type {typeof updated} */\n\t\tupdated: stores.updated\n\t};\n};\n\n/**\n * A readable store whose value contains page data.\n *\n * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n *\n * @type {import('svelte/store').Readable<import('@sveltejs/kit').Page>}\n */\nexport const page = {\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('page') : getStores().page;\n\t\treturn store.subscribe(fn);\n\t}\n};\n\n/**\n * A readable store.\n * When navigating starts, its value is a `Navigation` object with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties.\n * When navigating finishes, its value reverts to `null`.\n *\n * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n * @type {import('svelte/store').Readable<import('@sveltejs/kit').Navigation | null>}\n */\nexport const navigating = {\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('navigating') : getStores().navigating;\n\t\treturn store.subscribe(fn);\n\t}\n};\n\n/**\n * A readable store whose initial value is `false`. If [`version.pollInterval`](https://svelte.dev/docs/kit/configuration#version) is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to `true` when it detects one. `updated.check()` will force an immediate check, regardless of polling.\n *\n * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n * @type {import('svelte/store').Readable<boolean> & { check(): Promise<boolean> }}\n */\nexport const updated = {\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('updated') : getStores().updated;\n\n\t\tif (BROWSER) {\n\t\t\tupdated.check = store.check;\n\t\t}\n\n\t\treturn store.subscribe(fn);\n\t},\n\tcheck: () => {\n\t\tthrow new Error(\n\t\t\tBROWSER\n\t\t\t\t? 'Cannot check updated store before subscribing'\n\t\t\t\t: 'Can only check updated store in browser'\n\t\t);\n\t}\n};\n\n/**\n * @template {keyof ReturnType<typeof getStores>} Name\n * @param {Name} name\n * @returns {ReturnType<typeof getStores>[Name]}\n */\nfunction get_store(name) {\n\ttry {\n\t\treturn getStores()[name];\n\t} catch {\n\t\tthrow new Error(\n\t\t\t`Cannot subscribe to '${name}' store on the server outside of a Svelte component, as it is bound to the current request via component context. This prevents state from leaking between users.` +\n\t\t\t\t'For more information, see https://svelte.dev/docs/kit/state-management#avoid-shared-state-on-the-server'\n\t\t);\n\t}\n}\n","<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.status}</h1>\n<p>{$page.error?.message}</p>\n"],"names":["init","immutable","context","component_context","callbacks","props","deep_read_state","version","prev","d","derived","changed","key","get","user_pre_effect","observe_all","run_all","user_effect","fns","untrack","run","fn","signal","enable_legacy_mode_flag","getStores","stores","browser_stores","page","$.set_text","text","$page","_a"],"mappings":"6UAUO,SAASA,EAAKC,EAAY,GAAO,CACvC,MAAMC,EAAiDC,EAEjDC,EAAYF,EAAQ,EAAE,EAC5B,GAAI,CAACE,EAAW,OAEhB,IAAIC,EAAQ,IAAMC,EAAgBJ,EAAQ,CAAC,EAE3C,GAAID,EAAW,CACd,IAAIM,EAAU,EACVC,EAA2C,CAAA,EAG/C,MAAMC,EAAIC,EAAQ,IAAM,CACvB,IAAIC,EAAU,GACd,MAAMN,EAAQH,EAAQ,EACtB,UAAWU,KAAOP,EACbA,EAAMO,CAAG,IAAMJ,EAAKI,CAAG,IAC1BJ,EAAKI,CAAG,EAAIP,EAAMO,CAAG,EACrBD,EAAU,IAGZ,OAAIA,GAASJ,IACNA,CACV,CAAG,EAEDF,EAAQ,IAAMQ,EAAIJ,CAAC,CACrB,CAGKL,EAAU,EAAE,QACfU,EAAgB,IAAM,CACrBC,EAAYb,EAASG,CAAK,EAC1BW,EAAQZ,EAAU,CAAC,CACtB,CAAG,EAIFa,EAAY,IAAM,CACjB,MAAMC,EAAMC,EAAQ,IAAMf,EAAU,EAAE,IAAIgB,CAAG,CAAC,EAC9C,MAAO,IAAM,CACZ,UAAWC,KAAMH,EACZ,OAAOG,GAAO,YACjBA,EAAI,CAGN,CACH,CAAE,EAGGjB,EAAU,EAAE,QACfa,EAAY,IAAM,CACjBF,EAAYb,EAASG,CAAK,EAC1BW,EAAQZ,EAAU,CAAC,CACtB,CAAG,CAEH,CAQA,SAASW,EAAYb,EAASG,EAAO,CACpC,GAAIH,EAAQ,EAAE,EACb,UAAWoB,KAAUpB,EAAQ,EAAE,EAAGW,EAAIS,CAAM,EAG7CjB,EAAO,CACR,CC9EAkB,EAAyB,ECMlB,MAAMC,EAAY,IAAM,CAC9B,MAAMC,EAAmBC,EAElB,MAAA,CAEN,KAAM,CACL,UAAWD,EAAO,KAAK,SACxB,EAEA,WAAY,CACX,UAAWA,EAAO,WAAW,SAC9B,EAEA,QAASA,EAAO,OACjB,CACD,EASaE,EAAO,CACnB,UAAUN,EAAI,CAEN,OAD+CG,IAAY,KACrD,UAAUH,CAAE,CAAA,CAE3B,yKCjCKO,EAAAC,EAAAC,IAAM,MAAM,OACbC,EAAAD,IAAM,QAAN,YAAAC,EAAa,OAAO","x_google_ignoreList":[0,1,2,3]}